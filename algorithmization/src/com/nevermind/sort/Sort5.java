package com.nevermind.sort;

import java.util.Arrays;

 /*5. Сортировка вставками. Дана последовательность чисел  n a ,a , ,a 1 2 
    . Требуется переставить числа в порядке возрастания. Делается это следующим образом. Пусть
    a a ai , , , 1 2  - упорядоченная последовательность, т. е.
    a1  a2  an
    . Берется следующее число i+1 a и вставляется в последовательность так, чтобы новая
    последовательность была тоже возрастающей. Процесс производится до тех пор, пока все элементы от i +1 до n
    не будут перебраны. Примечание. Место помещения очередного элемента в отсортированную часть производить
    с помощью двоичного поиска. Двоичный поиск оформить в виде отдельной функции.*/

public class Sort5 {

    public static void main(String[] args) {

        //создаем массив а
        int[] a = new int[]{5, 3, 4, 2, 1, -7, 2, -3, -5, -3, -3, 10, 9, 8, 1, 7, 4, 3, 1, 2, 0, 0, 0, 0, -2, 10};

        System.out.println("Исходный массив:");
        System.out.println(Arrays.toString(a));

        sort5(a);

        System.out.println("Массив после сортировки : ");
        System.out.println(Arrays.toString(a));
    }

    private static void sort5(int[] a) {

//обход сортируемых элементов массива, 0-й считаем предвариетльно отсортированным
        for (int i = 1; i < a.length; i++) {

            //задаем переменную для хранения текущего элемента, которому мы ищем новое место в массиве
            int key;
            key = a[i];

            //определяем новую позицию для этого элемента бинарным поиском
            int position;
            position = binarySearch(a, 0, i - 1, key);

            //все элементы левее между старым и новым индексами элемента смещаем вправо на 1
            System.arraycopy(a, position, a, position + 1, i - position);

            //перемещаем элемент на освободившуюся позицию
            a[position] = key;
        }

    }

    //Реализация бинарного поиска с помощью рекурсии
    //l и r - левая и правая границы массива соответственно, x - элемент, для которого ищется место
    private static int binarySearch(int[] a, int l, int r, int x) {

        //определяем середину массива
        int mid;
        mid = l + (r - l) / 2;

        //если искомое значение левее середины
        if (x < a[mid]) {

            //если искомое значение лежит левее левого края массива, возвращаем его индекс
            if (mid == l) {
                return l;
            }

            //Иначе повторяем поиск по левой половине массива
            else {
                return binarySearch(a, l, mid, x);
            }
        }

        //если искомое значение правее середины
        else {

            //если искомое значение лежит правее правого края массива, возвращаем исходный индекс точки
            if (mid == r) {
                return r + 1;
            }

            //иначе повторяем поиск в правой половине массива
            else {
                return binarySearch(a, mid + 1, r, x);
            }
        }

    }
}

